---
layout: post
title: Java的垃圾回收机制
comments: true
author: "Yin Haomin"
tags:
    - 垃圾回收
    - 新生代
    - 老生带
    - 永久带
    - Eden
    - Survivor
---

本文来探讨Java的垃圾回收机制，以及我们开发中需要注意的问题。<br>
上文我们介绍了Java的堆，栈，本地方法栈，程序计数器，方法区等等内存区域，Java的内存回收主要是面对Java的堆和方法区的。<br>

#### 1. 判断对象是否已死的方式
(1). 引用计数法<br>
存在的问题是，当两个实例相互之间都有引用，但是二者没有其他的引用的时候，这部分内存将不会被回收。<br>
(2). 引用可达方式<br>
![gras](/images/stackheap/Object可达性判断.png)<br>

#### 作为GC Roots的地方:<br>
虚拟机栈（栈帧中的本地变量表）中引用的对象。<br>
方法区中类静态属性引用的对象。<br>
方法区中常量引用的对象。<br>
本地方法栈中JNI（即一般说的Native方法）引用的对象。<br>

#### 2. 垃圾回收的方式
(1). 标记-清除算法(Mark-Sweep)算法<br>
这种算法遍历并标记存活和不存活的对象，对于不存在的对象直接清除，导致的后果是造成内存碎片，但是好处是面对大量的存活对象，少量的不存活对象，效率比较高。<br>
(2). 标记-整理算法<br>
标记回收以后，将数据向左边移动，空余出来连续的内存空间，这样解决内存的分片问题。<br>
(3). 复制算法<br>
将内存分为两份，GC的时候，将还活着的对象拷贝到未使用的那份内存中，原来的内存全部回收。保证了内存的连续性。<br>
(4). 分代收集算法<br>
#### 其他说明
(1). finalize方法<br>
GC的时候，此方法只会被调用一次，如果在这个方法里面为变量设置一个引用，可以使变量逃脱一次回收。但是此方法不一定会被执行到。<br>

http://www.cnblogs.com/andy-zcx/p/5522836.html
