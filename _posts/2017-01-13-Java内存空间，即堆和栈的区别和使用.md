---
layout: post
title: Java内存空间，即堆和栈的区别和使用
comments: true
author: "Yin Haomin"
tags:
    - Memory
    - Stack
    - Heap
---

本文来总结下Java中的内存空间的分配，堆和栈的区别，它们各自的作用，如何会导致相应的异常，以及解决异常的方式。<br>

Java运行时的数据区包括程序计数器，方法区，堆，虚拟机栈，本地方法栈。我们主要关心的是堆和栈，下面我们来分析下他们的区别。<br>

#### 1. 堆和栈的简单比较

|类型|是否共享|存放的数据|生命周期|抛出异常|Re|
|:-------|:-------|:-------|:-------|:-------|:-------|
|Stack|No|方法执行的局部变量，动态链接，方法出口|与线程周期相同|StackOverFlowError,OutOfMemoryError|-|
|Heap|Yes|大部分new出来的对象|与程序周期相同|OutOfMemoryError|-|

#### 2. 堆的详细描述
(1). 堆是Java虚拟机管理的内存中占用最大的一块，Java的堆是由所有的线程共享的一块区域，在虚拟机启动的时候创建。<br>此处唯一的目的就是存放对象的实例，几乎所有的对象的实例都在这里分配内存。如下是Java虚拟机规范中的描述: <br>

```
The heap is the runtime data area from which memory for all class instances and arrays is allocated
```
而随着逃逸分析的发展和TLAB，并不是所有的对象都放在堆上分配。因为数据存放在heap上面的时候，设计锁堆，因此，会有比较大的项城开销，所以以下两种情况就不会把数据存放在堆上。<br>
    (A). 当虚拟机通过逃逸分析发现new出来的数据不能够从线程，方法中逃逸出去时，就把这个实例放在了stack里面。<br>
    (B). 当数据比较小，用过就丢的这种数据，JVM会将其放到TLAB(Thread Local Allocation Buffer)上，TLAB这个区域位于堆的Eden区域，为每个线程独占，所以不涉及锁的问题，开销比较小。<br>
(2). 堆是Garbage Collection个最主要的区域。从内存回收的角度看，因为现在的回收器大都采用的分代回收，所以，可以分为新生代和老年代。再细分的话，可以分为: Eden空间，From Survivor，To Survivor空间。<br>
(3). 堆存放在不连续的内存空间中，大小可以扩展。如果数据无法在堆上新建时，则会抛出OutOfMemory的异常。比如，不断的在堆上新建对象，直至内存被用完。<br>

#### 3. 栈的详细描述
(1). 栈是跟随运行出来的，与线程的生命周期相同，不会涉及到内存的回收。<br>
(2). 栈帧是一个重要的概念，每一个Java方法的调用，都是栈帧进栈出栈的过程。<br>
![gras](/images/stackheap/JVM栈和栈帧1.png)<br>
(3). 当在一个过程中，有大量的递归，导致栈中存储了大量的数据，直到不能再获取到新的内存空间，存储数据的时候，就会出现StackOverFlowError。<br>而当不断的新建新的线程，直至内存不够给栈分配的时候，会出现OutOfMmoryError<br>
(4). 当出现因为栈导致的内存OOM的时候，当线程的数量没有办法减少的时候，可以考虑减少最大堆和减小每个stack的大小。

#### 4. 方法区
(1). 方法区，也叫做永久带，用于存放虚拟机加载的类，常量，静态变量，JIT(Just-In-Time Compiler)编译的代码等等。
(2). 对于方法区的回收，一般是回收装在的类和常量池。
